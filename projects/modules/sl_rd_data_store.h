/***************************************************************************//**
 * @file  sl_rd_data_store.h
 * @brief Header file for sl_rd_data_store.c
 *******************************************************************************
 * # License
 * <b>Copyright 2025 Silicon Laboratories Inc. www.silabs.com</b>
 *******************************************************************************
 *
 * SPDX-License-Identifier: LicenseRef-MSLA
 *
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of the Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement
 * By installing, copying or otherwise using this software, you agree to the
 * terms of the MSLA.
 *
 ******************************************************************************/
#ifndef SL_RD_DATA_STORE_H_
#define SL_RD_DATA_STORE_H_

#include "stdbool.h"
#include "lib/memb.h"
#include "sl_uip_def.h"
#include "apps/Z-Wave/CC/RD_internal.h"

/**
 * IP association types.
 * The enum values must not be changed since they are persisted to the EEPROM file.
 */
typedef enum IP_ASSOC_TYPE {
  PERMANENT_IP_ASSOC = 1,
  LOCAL_IP_ASSOC     = 2,
  PROXY_IP_ASSOC     = 3
} ip_assoc_type_t;

/**
 * IP association structure.
 *
 * IP associations are persistent associations created with the IP Association
 * command class.
 */
typedef struct {
  void *next; /**< First item must be a pointer for the LIST macros */
  nodeid_t virtual_id; /**< This MUST be the first item following "next" (see ip_assoc_add_to_association_table()) */
  ip_assoc_type_t type; /**< unsolicited or association */
  uip_ip6addr_t resource_ip; /**< Association Destination IP */
  uint8_t resource_endpoint;  /**< From the IP_Association command. Association destination endpoint */
  uint16_t resource_port; /**< Association Destination port. NB: Stored in network byte order */
  uint8_t virtual_endpoint;   /**< From the ZIP_Command command */
  uint8_t grouping; /**< Grouping identifier */
  nodeid_t han_nodeid;   /**< Association Source node ID*/
  uint8_t han_endpoint; /**< Association Source endpoint*/
  uint8_t was_dtls;     /**< Was IP frame received via DTLS? */
  uint8_t mark_removal; /**< Set as a result of remove commands */
} ip_association_t;

/**
 * Read in the persistent data storage header.
 *
 * If the stored data do not match the information on the serial API,
 * or if it is not generated by a Z/IP Gateway, invalidate the storage
 * area, so that it will be re-initialized.
 *
 * If the stored data is recognized as one of the (supported) older
 * formats a conversion to the current format is automatically performed.
 *
 * @return false if the datastore cannot be converted (because of
 *               unknown or unsupported format).
 * @return true  otherwise.
 */
bool data_store_init(void);

/**
 * @brief Shut down the data store clean.
 *
 */
void data_store_exit(void);

/**
 * Read node entry from persistent storage. Return a newly allocated
 * rd_node_database_entry_t on success. The returned entry must be freed with
 * smfree
 */
rd_node_database_entry_t* rd_data_store_read(nodeid_t nodeID);

/**
 * Write a rd_node_database_entry_t and all its endpoints to storage.
 * This is called when a new node is added. Note that this call would clean up
 * the old entry together with its endpoints and create a new one.
 */
void rd_data_store_nvm_write(rd_node_database_entry_t *n);

/**
 * Update all node and endpoint info in persistent storage.
 *
 * Call when a the status of a node or its endpoints has changed. This
 * function assumes the number of endpoints to be matched with what entry
 * n has.
 */
void rd_data_store_update(rd_node_database_entry_t *n);

/**
 * Free up all storage associated with a node and its endpoints from \ref node_db.
 *
 * @param n Pointer to the node in \ref node_db.
 */
void rd_data_store_mem_free(rd_node_database_entry_t *n);

/**
 * Free the endpoint data, the dynamic data, and the node pointer for
 * a node in the \ref rd_data_store.
 */
void rd_data_store_nvm_free(rd_node_database_entry_t *n);

/**
 * Free endpoint from memory.
 */
void rd_store_mem_free_ep(rd_ep_database_entry_t* ep);

/**
 * Allocate and deallocate memory from the rd_data_mem pool.
 */
void* rd_data_mem_alloc(uint8_t size);
void rd_data_mem_free(void* p);

/**
 * Corrupt the magic field of EEPROM to make sure EEPROM will be reformatted.
 */
void rd_data_store_invalidate();

/**
 * Get ZGW home ID from RD datastore.
 */
uint32_t rd_zgw_homeid_get();

/**
 * Get ZGW node ID RD datastore.
 */
nodeid_t rd_zgw_nodeid_get();

void rd_datastore_persist_virtual_nodes(const nodeid_t *nodelist, size_t node_count);

size_t rd_datastore_unpersist_virtual_nodes(nodeid_t *nodelist, size_t max_node_count);

void rd_data_store_persist_associations(list_t ip_association_table);

void rd_datastore_unpersist_association(list_t ip_association_table, struct memb *ip_association_pool);

#endif /* SL_RD_DATA_STORE_H_ */
