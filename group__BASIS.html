<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>917 ZG23 WiFi ZWave Bridge: Z-Wave Basis API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">917 ZG23 WiFi ZWave Bridge
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Z-Wave Basis API </div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1c191ce310398f9a48046aced5278dff" id="r_ga1c191ce310398f9a48046aced5278dff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1c191ce310398f9a48046aced5278dff">ZW_REQUEST_NETWORK_UPDATE</a>(FUNC)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0b2d07725f08e848a3106dca270fca40" id="r_ga0b2d07725f08e848a3106dca270fca40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0b2d07725f08e848a3106dca270fca40">ZW_Random</a> ()</td></tr>
<tr class="memitem:ga7a6d32ff47739f7313ddf2c1789a1fdf" id="r_ga7a6d32ff47739f7313ddf2c1789a1fdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ZW__typedefs_8h.html#ad2f8ed01c1733d4eab0932d970abaa4c">BOOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7a6d32ff47739f7313ddf2c1789a1fdf">ZW_RequestNetWorkUpdate</a> (void(*complFunc)(<a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>))</td></tr>
<tr class="memitem:ga11e9f32e843403ccb701ec2c881b2b4e" id="r_ga11e9f32e843403ccb701ec2c881b2b4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga11e9f32e843403ccb701ec2c881b2b4e">ZW_ExploreRequestInclusion</a> ()</td></tr>
<tr class="memitem:gafd919859144cec8e159de6db49cd10d4" id="r_gafd919859144cec8e159de6db49cd10d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafd919859144cec8e159de6db49cd10d4">ZW_GetProtocolStatus</a> ()</td></tr>
<tr class="memitem:gad5b2aed81877705c0f425f26026a69f6" id="r_gad5b2aed81877705c0f425f26026a69f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad5b2aed81877705c0f425f26026a69f6">SerialAPI_WatchdogStart</a> ()</td></tr>
<tr class="memitem:gab79d35a5e6d3f59fe05c115a74a55e64" id="r_gab79d35a5e6d3f59fe05c115a74a55e64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab79d35a5e6d3f59fe05c115a74a55e64">ZW_SendNodeInformation</a> (uint16_t destNode, <a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> txOptions, <a class="el" href="ZW__typedefs_8h.html#a5bcade2e3214a843e893e29e9fbc474d">VOID_CALLBACKFUNC</a>(completedFunc)(<a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>))</td></tr>
<tr class="memitem:gae8c2136137e04675a0f0a6890af51673" id="r_gae8c2136137e04675a0f0a6890af51673"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae8c2136137e04675a0f0a6890af51673">ZW_RFPowerLevelSet</a> (<a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> powerLevel)</td></tr>
<tr class="memitem:gad59ef739c8873ab6323c5b7a635281f4" id="r_gad59ef739c8873ab6323c5b7a635281f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad59ef739c8873ab6323c5b7a635281f4">ZW_RFPowerLevelGet</a> (void)</td></tr>
<tr class="memitem:gadbe3bef4396056eb8be4636f6694d3b4" id="r_gadbe3bef4396056eb8be4636f6694d3b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadbe3bef4396056eb8be4636f6694d3b4">ZW_RFRegionSet</a> (<a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> rfregion)</td></tr>
<tr class="memitem:ga6294347601292acf17bf37cda0c3d114" id="r_ga6294347601292acf17bf37cda0c3d114"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6294347601292acf17bf37cda0c3d114">ZW_RFRegionGet</a> (void)</td></tr>
<tr class="memitem:gab7eb08b2c0ee8a4913b5380850d563ce" id="r_gab7eb08b2c0ee8a4913b5380850d563ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab7eb08b2c0ee8a4913b5380850d563ce">ZW_SoftReset</a> (void)</td></tr>
<tr class="memitem:ga9addd6fccecaa4ddbfe734ca83b794f2" id="r_ga9addd6fccecaa4ddbfe734ca83b794f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9addd6fccecaa4ddbfe734ca83b794f2">ZW_SendTestFrame</a> (uint16_t nodeID, <a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> powerLevel, <a class="el" href="ZW__typedefs_8h.html#a5bcade2e3214a843e893e29e9fbc474d">VOID_CALLBACKFUNC</a>(func)(<a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> txStatus))</td></tr>
<tr class="memitem:gaa70ec605ef56357c27c8d4ea1ca986cb" id="r_gaa70ec605ef56357c27c8d4ea1ca986cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ZW__typedefs_8h.html#ad2f8ed01c1733d4eab0932d970abaa4c">BOOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa70ec605ef56357c27c8d4ea1ca986cb">ZW_GetRandomWord</a> (<a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> *randomWord, <a class="el" href="ZW__typedefs_8h.html#ad2f8ed01c1733d4eab0932d970abaa4c">BOOL</a> bResetRadio)</td></tr>
<tr class="memitem:ga9c99dba6e2845a5f63df2ef1a79d0f08" id="r_ga9c99dba6e2845a5f63df2ef1a79d0f08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9c99dba6e2845a5f63df2ef1a79d0f08">ZW_ExploreRequestExclusion</a> ()</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>This section defines functions that are implemented in all Z Wave nodes. </p>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ga1c191ce310398f9a48046aced5278dff" name="ga1c191ce310398f9a48046aced5278dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c191ce310398f9a48046aced5278dff">&#9670;&#160;</a></span>ZW_REQUEST_NETWORK_UPDATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZW_REQUEST_NETWORK_UPDATE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>FUNC</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code hl_function" href="#ga7a6d32ff47739f7313ddf2c1789a1fdf">ZW_RequestNetWorkUpdate</a>(FUNC))</div>
<div class="ttc" id="agroup__BASIS_html_ga7a6d32ff47739f7313ddf2c1789a1fdf"><div class="ttname"><a href="#ga7a6d32ff47739f7313ddf2c1789a1fdf">ZW_RequestNetWorkUpdate</a></div><div class="ttdeci">BOOL ZW_RequestNetWorkUpdate(void(*complFunc)(BYTE))</div><div class="ttdef"><b>Definition</b> Serialapi.c:3131</div></div>
</div><!-- fragment --><p>Used to request network topology updates from the SUC/SIS node. The update is done on protocol level and any changes are notified to the application by calling the sl_appl_controller_update).</p>
<p>Secondary controllers can only use this call when a SUC is present in the network. All controllers can use this call in case a SUC ID Server (SIS) is available.</p>
<p>Routing Slaves can only use this call, when a SUC is present in the network. In case the Routing Slave has called ZW_RequestNewRouteDestinations prior to ZW_RequestNetWorkUpdate, then Return Routes for the destinations specified by the application in ZW_RequestNewRouteDestinations will be updated along with the SUC Return Route.</p>
<dl class="section note"><dt>Note</dt><dd>The SUC can only handle one network update at a time, so care should be taken not to have all the controllers in the network ask for updates at the same time.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This API call will generate a lot of network activity that will use bandwidth and stress the SUC in the network. Therefore, network updates should be requested as seldom as possible and never more often that once every hour from a controller.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE If the updating process is started. </dd>
<dd>
FALSE If the requesting controller is the SUC node or the SUC node is unknown.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">completedFunc</td><td>IN Transmit complete call back.</td></tr>
  </table>
  </dd>
</dl>
<p>Callback function Parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">txStatus</td><td>IN Status of command: -ZW_SUC_UPDATE_DONE The update process succeeded. -ZW_SUC_UPDATE_ABORT The update process aborted because of an error. -<a class="el" href="ZW__controller__api_8h.html#a6a2cee87446aec3a5b25e492ad129acb">ZW_SUC_UPDATE_WAIT</a> The SUC node is busy. -<a class="el" href="ZW__controller__api_8h.html#adb4be75fb3d83d89316a06887fbe1b47">ZW_SUC_UPDATE_DISABLED</a> The SUC functionality is disabled.<ul>
<li><a class="el" href="ZW__controller__api_8h.html#af703a0b9c06c024185fa38fd6af1b62a">ZW_SUC_UPDATE_OVERFLOW</a> The controller requested an update after more than 64 changes have occurred in the network. The update information is then out of date in respect to that controller. In this situation the controller have to make a replication before trying to request any new network updates.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Timeout: 65s Exption recovery: Resume normal operation, no recovery needed</p>
<p>Serial API: HOST-&gt;ZW: REQ | 0x53 | funcID ZW-&gt;HOST: RES | 0x53 | retVal ZW-&gt;HOST: REQ | 0x53 | funcID | txStatus </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="gad5b2aed81877705c0f425f26026a69f6" name="gad5b2aed81877705c0f425f26026a69f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b2aed81877705c0f425f26026a69f6">&#9670;&#160;</a></span>SerialAPI_WatchdogStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SerialAPI_WatchdogStart </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transmit data buffer to a list of Z-Wave Nodes (multicast frame) in bridge mode.</p>
<p>Invokes the <a class="el" href="ZW__transport__api_8h.html#ada1a62e51417c0ce108d80074152db8c">ZW_SendDataMulti_Bridge()</a> function on the Z-Wave chip via serial API.</p>
<p>This function should be used also when the gateway is the source node because the function <a class="el" href="ZW__transport__api_8h.html#a2401d0ecc8cc957efa6ddb288e2da283">ZW_SendDataMulti()</a> is not available on a chip with bridge controller library (which is what the gateway uses).</p>
<p>NB: This function has a different name than the actual Z-Wave API function. This is intentional since pre-processor defines in <a class="el" href="ZW__transport__api_8h.html" title="Z-Wave Transport Application layer interface.">ZW_transport_api.h</a> re-maps ZW_SendDataMulti and ZW_SendDataMulti_Bridge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcNodeID</td><td>Source nodeID - if 0xFF then controller is set as source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstNodeMask</td><td>Node mask where the bits corresponding to the destination node IDs are set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data buffer pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataLength</td><td>Data buffer length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txOptions</td><td>Transmit option flags </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">completedFunc</td><td>Transmit completed call back function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if transmitter queue overflow</dd></dl>
<ul>
<li>Enable Watchdog and start kicking it in the Z-Wave chip. serialapi{ HOST -&gt; ZW: REQ | 0xD2 }</li>
<li>See Serialpi.h for doxygen documentation *&zwj;/ </li>
</ul>

</div>
</div>
<a id="ga9c99dba6e2845a5f63df2ef1a79d0f08" name="ga9c99dba6e2845a5f63df2ef1a79d0f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c99dba6e2845a5f63df2ef1a79d0f08">&#9670;&#160;</a></span>ZW_ExploreRequestExclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> ZW_ExploreRequestExclusion </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sends out an explorer frame requesting exclusion from the network. If the exclusion request is accepted by a controller in network wide exclusion mode then the application on this node will get notified through the callback from the <a class="el" href="Serialapi_8c.html#ae36ebd5cfee4608d12941ec8c4f058ec">ZW_SetLearnMode()</a> function. Once a callback is received from <a class="el" href="Serialapi_8c.html#ae36ebd5cfee4608d12941ec8c4f058ec">ZW_SetLearnMode()</a> saying that the exclusion process has started the application should not make further calls to this function.</p>
<dl class="section note"><dt>Note</dt><dd>Recommend not to call this function more than once every 4 seconds.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE Exclusion request queued for transmission </dd>
<dd>
FALSE Node is not in learn mode \serialapi{ HOST-&gt;ZW: REQ | 0x5E ZW-&gt;HOST: RES | 0x5E | retVal } </dd></dl>

</div>
</div>
<a id="ga11e9f32e843403ccb701ec2c881b2b4e" name="ga11e9f32e843403ccb701ec2c881b2b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11e9f32e843403ccb701ec2c881b2b4e">&#9670;&#160;</a></span>ZW_ExploreRequestInclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> ZW_ExploreRequestInclusion </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\macro{<a class="el" href="ZW__basis__api_8h.html#ad715d5d1fee923b15f0690d39698fcd7">ZW_EXPLORE_REQUEST_INCLUSION()</a>} This function sends out an explorer frame requesting inclusion into a network. If the inclusion request is accepted by a controller in network wide inclusion mode then the application on this node will get notified through the callback from the <a class="el" href="Serialapi_8c.html#ae36ebd5cfee4608d12941ec8c4f058ec">ZW_SetLearnMode()</a> function. Once a callback is received from <a class="el" href="Serialapi_8c.html#ae36ebd5cfee4608d12941ec8c4f058ec">ZW_SetLearnMode()</a> saying that the inclusion process has started the application should not make further calls to this function. </p><dl class="section return"><dt>Returns</dt><dd>TRUE Inclusion request queued for transmission </dd>
<dd>
FALSE Node is not in learn mode</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Recommend not to call this function more than once every 4 seconds. \serialapi{ HOST-&gt;ZW: REQ|0x5E ZW-&gt;HOST: RES|0x5E|retVal }</dd></dl>
<p>This function sends out an explorer frame requesting inclusion into a network. If the inclusion request is accepted by a controller in network wide inclusion mode then the application on this node will get notified through the callback from the <a class="el" href="Serialapi_8c.html#ae36ebd5cfee4608d12941ec8c4f058ec">ZW_SetLearnMode()</a> function. Once a callback is received from <a class="el" href="Serialapi_8c.html#ae36ebd5cfee4608d12941ec8c4f058ec">ZW_SetLearnMode()</a> saying that the inclusion process has started the application should not make further calls to this function.</p>
<dl class="section note"><dt>Note</dt><dd>Recommend not to call this function more than once every 4 seconds.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE Inclusion request queued for transmission </dd>
<dd>
FALSE Node is not in learn mode \serialapi{ HOST-&gt;ZW: REQ | 0x5E ZW-&gt;HOST: RES | 0x5E | retVal } </dd></dl>

</div>
</div>
<a id="gafd919859144cec8e159de6db49cd10d4" name="gafd919859144cec8e159de6db49cd10d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd919859144cec8e159de6db49cd10d4">&#9670;&#160;</a></span>ZW_GetProtocolStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> ZW_GetProtocolStatus </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\macro{<a class="el" href="ZW__basis__api_8h.html#ad1397b58b9b0472dc47df50091f83240">ZW_GET_PROTOCOL_STATUS()</a>} Report the status of the protocol. The function return a mask telling which protocol function is currently running </p><dl class="section return"><dt>Returns</dt><dd>Zero Protocol is idle. </dd>
<dd>
ZW_PROTOCOL_STATUS_ROUTING Protocol is analyzing the routing table. </dd>
<dd>
ZW_PROTOCOL_STATUS_SUC SUC sends pending updates. \serialapi{ HOST-&gt;ZW: REQ | 0xBF ZW-&gt;HOST: RES | 0xBF | retVal }</dd></dl>
<p>\macro{<a class="el" href="ZW__basis__api_8h.html#ad1397b58b9b0472dc47df50091f83240">ZW_GET_PROTOCOL_STATUS()</a>}</p>
<p>Report the status of the protocol.</p>
<p>The function return a mask telling which protocol function is currently running</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the protocol status as one of the following:<ul>
<li>Zero Protocol is idle.</li>
<li><a class="el" href="ZW__basis__api_8h.html#aee588b5bb30fc23b433c8e74584a116c">ZW_PROTOCOL_STATUS_ROUTING</a> Protocol is analyzing the routing table.</li>
<li><a class="el" href="ZW__basis__api_8h.html#a130142ba2c8e2103b0aabfb2051e47a6">ZW_PROTOCOL_STATUS_SUC</a> SUC sends pending updates.</li>
</ul>
</dd></dl>
<p>\serialapi{ HOST-&gt;ZW: REQ | 0xBF ZW-&gt;HOST: RES | 0xBF | retVal } </p>

</div>
</div>
<a id="gaa70ec605ef56357c27c8d4ea1ca986cb" name="gaa70ec605ef56357c27c8d4ea1ca986cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa70ec605ef56357c27c8d4ea1ca986cb">&#9670;&#160;</a></span>ZW_GetRandomWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ZW__typedefs_8h.html#ad2f8ed01c1733d4eab0932d970abaa4c">BOOL</a> ZW_GetRandomWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> *</td>          <td class="paramname"><span class="paramname"><em>randomWord</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ZW__typedefs_8h.html#ad2f8ed01c1733d4eab0932d970abaa4c">BOOL</a></td>          <td class="paramname"><span class="paramname"><em>bResetRadio</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The API call generates a random word using the ZW0201/ZW0301 builtin random number generator (RNG). If RF needs to be in Receive then ZW_SetRFReceiveMode should be called afterwards. </p><dl class="section return"><dt>Returns</dt><dd>TRUE If possible to generate random number. </dd>
<dd>
FALSE If not possible e.g. RF not powered down. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">randomWord</td><td>Pointer to word variable, which should receive the random word. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bResetRadio</td><td>If TRUE the RF radio is reinitialized after generating the random word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The ZW0201/ZW0301 RNG is based on the RF transceiver, which must be in powerdown state (see ZW_SetRFReceiveMode) to assure proper operation of the RNG. Remember to call ZW_GetRandomWord with bResetRadio = TRUE when the last random word is to be generated. This is needed for the RF to be reinitialized, so that it can be used to transmit and receive again.<ul>
<li>\macro{ZW_GET_RANDOM_WORD(randomWord\,bResetRadio)} \serialapi{ HOST -&gt; ZW: REQ | 0x1C | noRandomBytes ZW -&gt; HOST: RES | 0x1C | randomGenerationSuccess | noRandomBytesGenerated | randombytes[] } </li>
</ul>
</dd>
<dd>
The Serial API function 0x1C makes use of the ZW_GetRandomWord to generate a specified number of random bytes and takes care of the handling of the RF:<ul>
<li>Set the RF in powerdown prior to calling the ZW_GetRandomWord the first time, if not possible then return result to HOST.</li>
<li>Call ZW_GetRandomWord until enough random bytes generated or ZW_GetRandomWord returns FALSE.</li>
<li>Call ZW_GetRandomWord with bResetRadio = TRUE to reinitialize the radio.</li>
<li>Call ZW_SetRFReceiveMode with TRUE if the serialAPI hardware is a listening device or with FALSE if it is a non-listening device.</li>
<li>Return result to HOST.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">noRandomBytes</td><td>to generate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">randomGenerationSuccess</td><td>TRUE if random bytes could be generated </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">noRandomBytesGenerated</td><td>Number of random numbers generated </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">randombytes[]</td><td>Array of generated random bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0b2d07725f08e848a3106dca270fca40" name="ga0b2d07725f08e848a3106dca270fca40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b2d07725f08e848a3106dca270fca40">&#9670;&#160;</a></span>ZW_Random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> ZW_Random </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\macro{<a class="el" href="ZW__basis__api_8h.html#ade3dc23ef25a7d8008082ab345868350">ZW_RANDOM()</a>}</p>
<p>A pseudo-random number generator that generates a sequence of numbers, the elements of which are approximately independent of each other. The same sequence of pseudo-random numbers will be repeated in case the module is power cycled. The Z-Wave protocol uses also this function in the random backoff algorithm etc.</p>
<dl class="section return"><dt>Returns</dt><dd>Random number (0 â€“ 0xFF)</dd></dl>
<p>\serialapi{ HOST-&gt;ZW: REQ | 0x1D ZW-&gt;HOST: RES | 0x1D | rndNo } </p>

</div>
</div>
<a id="ga7a6d32ff47739f7313ddf2c1789a1fdf" name="ga7a6d32ff47739f7313ddf2c1789a1fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a6d32ff47739f7313ddf2c1789a1fdf">&#9670;&#160;</a></span>ZW_RequestNetWorkUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ZW__typedefs_8h.html#ad2f8ed01c1733d4eab0932d970abaa4c">BOOL</a> ZW_RequestNetWorkUpdate </td>
          <td>(</td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>complFunc&#160;</em></span>)(<a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>)</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\macro{ <a class="el" href="#ga1c191ce310398f9a48046aced5278dff">ZW_REQUEST_NETWORK_UPDATE(FUNC)</a> } Used to request network topology updates from the SUC/SIS node. The update is done on protocol level and any changes are notified to the application by calling the ApplicationControllerUpdate). Secondary controllers can only use this call when a SUC is present in the network. All controllers can use this call in case a SUC ID Server (SIS) is available. Routing Slaves can only use this call, when a SUC is present in the network. In case the Routing Slave has called ZW_RequestNewRouteDestinations prior to ZW_RequestNetWorkUpdate, then Return Routes for the destinations specified by the application in ZW_RequestNewRouteDestinations will be updated along with the SUC Return Route. </p><dl class="section note"><dt>Note</dt><dd>The SUC can only handle one network update at a time, so care should be taken not to have all the controllers in the network ask for updates at the same time. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This API call will generate a lot of network activity that will use bandwidth and stress the SUC in the network. Therefore, network updates should be requested as seldom as possible and never more often that once every hour from a controller.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE If the updating process is started. FALSE If the requesting controller is the SUC node or the SUC node is unknown. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">completedFunc</td><td>Transmit complete call back. </td></tr>
    <tr><td class="paramname">txStatus</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>ZW_SUC_UPDATE_DONE The update process succeeded. ZW_SUC_UPDATE_ABORT The update process aborted because of an error. ZW_SUC_UPDATE_WAIT The SUC node is busy. ZW_SUC_UPDATE_DISABLED The SUC functionality is disabled. ZW_SUC_UPDATE_OVERFLOW The controller requested an update after more than 64 changes have occurred in the network. The update information is then out of date in respect to that controller. In this situation the controller have to make a replication before trying to request any new network updates. <b>Timeout:</b> 35s</p>
<p><b>Exption recovery:</b> Resume normal operation, no recovery needed</p>
<p>\serialapi{ HOST-&gt;ZW: REQ | 0x53 | funcID ZW-&gt;HOST: RES | 0x53 | retVal ZW-&gt;HOST: REQ | 0x53 | funcID | txStatus } </p>

</div>
</div>
<a id="gad59ef739c8873ab6323c5b7a635281f4" name="gad59ef739c8873ab6323c5b7a635281f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad59ef739c8873ab6323c5b7a635281f4">&#9670;&#160;</a></span>ZW_RFPowerLevelGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> ZW_RFPowerLevelGet </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\macro{<a class="el" href="ZW__basis__api_8h.html#a0e7d5e7072d8820d5a5de22d57654f0a">ZW_RF_POWERLEVEL_GET()</a>}</p>
<p>Get the current power level used in RF transmitting.</p>
<dl class="section note"><dt>Note</dt><dd>This function should only be used in an install/test link situation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The power level currently in effect during RF transmissions.</dd></dl>
<p>\serialapi{ HOST-&gt;ZW: REQ | 0xBA ZW-&gt;HOST: RES | 0xBA | powerlevel }</p>
<p>Get the current power level used in RF transmitting. </p><dl class="section note"><dt>Note</dt><dd>This function should only be used in an install/test link situation. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The power level currently in effect during RF transmissions </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae8c2136137e04675a0f0a6890af51673">ZW_RFPowerLevelSet</a></dd></dl>
<p>\serialapi{ HOST-&gt;ZW: REQ | 0xBA ZW-&gt;HOST: RES | 0xBA | powerlevel } </p>

</div>
</div>
<a id="gae8c2136137e04675a0f0a6890af51673" name="gae8c2136137e04675a0f0a6890af51673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8c2136137e04675a0f0a6890af51673">&#9670;&#160;</a></span>ZW_RFPowerLevelSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> ZW_RFPowerLevelSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a></td>          <td class="paramname"><span class="paramname"><em>powerLevel</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the power level used in RF transmitting. The actual RF power is dependent on the settings for transmit power level in App_RFSetup.a51. If this value is changed from using the default library value the resulting power levels might differ from the intended values. The returned value is however always the actual one used.</p>
<dl class="section note"><dt>Note</dt><dd>This function should only be used in an install/test link situation and the power level should always be set back to normalPower when the testing is done.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">powerLevel</td><td>powerlevel to use in RF transmission, valid values:<ul>
<li><a class="el" href="ZW__basis__api_8h.html#ae6c835aceb634f0fdf05741116530156add5a5de0041f0098bad537cc97ebf35b">normalPower</a> Max power possible</li>
<li><a class="el" href="ZW__basis__api_8h.html#ae6c835aceb634f0fdf05741116530156a68ab6b35e368262efbc552456cadb046">minus1dBm</a> Normal power - 1dB (mapped to minus2dB )</li>
<li><a class="el" href="ZW__basis__api_8h.html#ae6c835aceb634f0fdf05741116530156abdebe4f9380f9ef1a84c6dc2686474ab">minus2dBm</a> Normal power - 2dB</li>
<li><a class="el" href="ZW__basis__api_8h.html#ae6c835aceb634f0fdf05741116530156adf3ec4441190ec5c20277c3e60efd82f">minus3dBm</a> Normal power - 3dB (mapped to minus4dB)</li>
<li><a class="el" href="ZW__basis__api_8h.html#ae6c835aceb634f0fdf05741116530156adf6c9ea183aea5eacd330c5b2e1bc061">minus4dBm</a> Normal power - 4dB</li>
<li><a class="el" href="ZW__basis__api_8h.html#ae6c835aceb634f0fdf05741116530156ab2bcfc58fea4e0189183d477755a98d1">minus5dBm</a> Normal power - 5dB (mapped to minus6dB)</li>
<li><a class="el" href="ZW__basis__api_8h.html#ae6c835aceb634f0fdf05741116530156afcd18cf7c068f9aa0e40812109527967">minus6dBm</a> Normal power - 6dB</li>
<li><a class="el" href="ZW__basis__api_8h.html#ae6c835aceb634f0fdf05741116530156a2fd2ffda481d681d58cecbabff41875f">minus7dBm</a> Normal power - 7dB (mapped to minus8dB)</li>
<li><a class="el" href="ZW__basis__api_8h.html#ae6c835aceb634f0fdf05741116530156adb3586dd7777b3a371acf76a2a1ab69e">minus8dBm</a> Normal power - 8dB</li>
<li><a class="el" href="ZW__basis__api_8h.html#ae6c835aceb634f0fdf05741116530156a7e5165976ebad5647b0430110a6b603e">minus9dBm</a> Normal power - 9dB (mapped to minus10dB) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The powerlevel set.</dd></dl>
<p>\macro{<a class="el" href="ZW__basis__api_8h.html#ae119da7956d6481f3e14d77d96d4b76f">ZW_RF_POWERLEVEL_SET(POWERLEVEL)</a>}</p>
<p>\serialapi{ HOST-&gt;ZW: REQ | 0x17 | powerLevel ZW-&gt;HOST: RES | 0x17 | retVal } </p>

</div>
</div>
<a id="ga6294347601292acf17bf37cda0c3d114" name="ga6294347601292acf17bf37cda0c3d114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6294347601292acf17bf37cda0c3d114">&#9670;&#160;</a></span>ZW_RFRegionGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> ZW_RFRegionGet </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\macro{<a class="el" href="ZW__basis__api_8h.html#aea2be88fd60b551896016dd952cd8c00">ZW_RF_REGION_GET()</a>}</p>
<p>Get the current RF region setting</p>
<dl class="section return"><dt>Returns</dt><dd>The RF region currently in effect</dd></dl>
<p>\serialapi{ HOST-&gt;ZW: REQ | 0x0B | 0x20 ZW-&gt;HOST: RES | 0x0B | 0x20 | RFRegion }</p>
<p>Get the current RF region </p><dl class="section return"><dt>Returns</dt><dd>The RF region currently in effect </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga6294347601292acf17bf37cda0c3d114">ZW_RFRegionGet</a></dd></dl>
<p>\serialapi{ HOST-&gt;ZW: REQ | 0x0B | 0x20 ZW-&gt;HOST: RES | 0x0B | 0x20 | RFRegion } </p>

</div>
</div>
<a id="gadbe3bef4396056eb8be4636f6694d3b4" name="gadbe3bef4396056eb8be4636f6694d3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbe3bef4396056eb8be4636f6694d3b4">&#9670;&#160;</a></span>ZW_RFRegionSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> ZW_RFRegionSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a></td>          <td class="paramname"><span class="paramname"><em>rfregion</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\macro{<a class="el" href="ZW__basis__api_8h.html#af2e861c68e3858fd0a81c7d40ba008b7">ZW_RF_REGION_SET(RFRegion)</a>}</p>
<p>Set the current RF region setting to RFRegion</p>
<dl class="section return"><dt>Returns</dt><dd>0 - failed, 1 - success</dd></dl>
<p>\serialapi{ HOST-&gt;ZW: REQ | 0x0B | 0x40 | RFRegion ZW-&gt;HOST: RES | 0x0B | 0x40 | CmdRes }</p>
<p>Set the current RF region setting to RFRegion </p><dl class="section return"><dt>Returns</dt><dd>0 - failed, 1 - success </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gadbe3bef4396056eb8be4636f6694d3b4">ZW_RFRegionSet</a></dd></dl>
<p>\serialapi{ HOST-&gt;ZW: REQ | 0x0B | 0x40 | RFRegion ZW-&gt;HOST: RES | 0x0B | 0x40 | CmdRes } </p>

</div>
</div>
<a id="gab79d35a5e6d3f59fe05c115a74a55e64" name="gab79d35a5e6d3f59fe05c115a74a55e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab79d35a5e6d3f59fe05c115a74a55e64">&#9670;&#160;</a></span>ZW_SendNodeInformation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> ZW_SendNodeInformation </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>destNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a></td>          <td class="paramname"><span class="paramname"><em>txOptions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ZW__typedefs_8h.html#a5bcade2e3214a843e893e29e9fbc474d">VOID_CALLBACKFUNC</a>(completedFunc)(<a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\macro{ <a class="el" href="ZW__basis__api_8h.html#a1526a7bfd5e1fac52899e61903492f1a">ZW_SEND_NODE_INFO(node,option,func)</a> } Create and transmit a "Node Information" frame. The Z Wave transport layer builds a frame, request application node information (see ApplicationNodeInformation) and queue the "Node Information" frame for transmission. The completed call back function (completedFunc) is called when the transmission is complete.</p>
<p>The Node Information Frame is a protocol frame and will therefore not be directly available to the application on the receiver. The API call <a class="el" href="Serialapi_8c.html#ae36ebd5cfee4608d12941ec8c4f058ec">ZW_SetLearnMode()</a> can be used to instruct the protocol to pass the Node Information Frame to the application.</p>
<p>When <a class="el" href="#gab79d35a5e6d3f59fe05c115a74a55e64">ZW_SendNodeInformation()</a> is used in learn mode for adding or removing the node from the network the transmit option TRANSMIT_OPTION_LOW_POWER should NOT be used. </p><dl class="section note"><dt>Note</dt><dd>ZW_SendNodeInformation uses the transmit queue in the API, so using other transmit functions before the complete callback has been called by the API is not recommended.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE If frame was put in the transmit queue </dd>
<dd>
FALSE If it was not (callback will not be called)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destNode</td><td>Destination Node ID (NODE_BROADCAST == all nodes) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txOptions</td><td>Transmit option flags. (see ZW_SendData) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">completedFunc</td><td>Transmit completed call back function</td></tr>
  </table>
  </dd>
</dl>
<p>Callback function Parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">txStatus</td><td>(see <a class="el" href="Serialapi_8c.html#a6c0de8f0733bc1d12854362f5549d297">ZW_SendData</a>)</td></tr>
  </table>
  </dd>
</dl>
<p>Timeout: 65s Exception recovery: Resume normal operation, no recovery needed \serialapi{ HOST-&gt;ZW: REQ | 0x12 | destNode | txOptions | funcID (LR) HOST-&gt;ZW: REQ | 0x12 | destNode [MSB] | destNode [LSB] | txOptions | funcID ZW-&gt;HOST: RES | 0x12 | retVal ZW-&gt;HOST: REQ | 0x12 | funcID | txStatus }</p>
<p>Create and transmit a node information broadcast frame </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>if transmitter queue overflow </td></tr>
    <tr><td class="paramname">FALSE</td><td>if transmitter queue overflow </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9addd6fccecaa4ddbfe734ca83b794f2" name="ga9addd6fccecaa4ddbfe734ca83b794f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9addd6fccecaa4ddbfe734ca83b794f2">&#9670;&#160;</a></span>ZW_SendTestFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> ZW_SendTestFrame </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>nodeID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a></td>          <td class="paramname"><span class="paramname"><em>powerLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ZW__typedefs_8h.html#a5bcade2e3214a843e893e29e9fbc474d">VOID_CALLBACKFUNC</a>(func)(<a class="el" href="ZW__typedefs_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> txStatus)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\macro {<a class="el" href="ZW__basis__api_8h.html#a8ba99eb722315ee58fc23d9c72af6dfd">ZW_SEND_TEST_FRAME(nodeID, power, func)</a>}</p>
<p>Send a test frame directly to nodeID without any routing, RF transmission power is previously set to powerlevel by calling ZW_RF_POWERLEVEL_SET. The test frame is acknowledged at the RF transmission powerlevel indicated by the parameter powerlevel by nodeID (if the test frame got through). This test will be done using 9600 kbit/s transmission rate.</p>
<dl class="section note"><dt>Note</dt><dd>This function should only be used in an install/test link situation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[IN]</td><td>nodeID Node ID on the node ID (1..232) the test frame should be transmitted to. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[IN]</td><td>powerLevel Powerlevel to use in RF transmission, valid values:<ul>
<li>normalPower Max power possible</li>
<li>minus1dB Normal power - 1dB (mapped to minus2dB )</li>
<li>minus2dB Normal power - 2dB</li>
<li>minus3dB Normal power - 3dB (mapped to minus4dB)</li>
<li>minus4dB Normal power - 4dB</li>
<li>minus5dB Normal power - 5dB (mapped to minus6dB)</li>
<li>minus6dB Normal power - 6dB</li>
<li>minus7dB Normal power - 7dB (mapped to minus8dB)</li>
<li>minus8dB Normal power - 8dB</li>
<li>minus9dB Normal power - 9dB (mapped to minus10dB) </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callback function called when done. Callback function Parameters: </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txStatus</td><td>(see <a class="el" href="Serialapi_8c.html#a6c0de8f0733bc1d12854362f5549d297">ZW_SendData</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE If transmit queue overflow.</dd></dl>
<p>Timeout: 200ms Exception recovery: Resume normal operation, no recovery needed </p>

</div>
</div>
<a id="gab7eb08b2c0ee8a4913b5380850d563ce" name="gab7eb08b2c0ee8a4913b5380850d563ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7eb08b2c0ee8a4913b5380850d563ce">&#9670;&#160;</a></span>ZW_SoftReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZW_SoftReset </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\macro{<a class="el" href="group__ZWCMD.html#gadb0c4da6731acd28a449f513cdcc1eb3">ZW_SoftReset()</a>}</p>
<p>Reset the Z-Wave module</p>
<dl class="section note"><dt>Note</dt><dd>USB modules will do a disconnect - connect when this command is issued. This means that the module may get a new address on the USB bus. This will make the old file handle to the USB serial interface invalid.</dd></dl>
<p>\serialapi{ HOST-&gt;ZW: REQ | 0x08 }</p>
<p>Make the Z-Wave chip reset itself. Recent Z-Wave versions (at least 6.80 and 7.00) will return FUNC_ID_SERIAL_API_STARTED once restarted. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
